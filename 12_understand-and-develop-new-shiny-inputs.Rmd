# Understand and develop new Shiny inputs

**Learning objectives:**

- Understand how Shiny inputs work
- Understand how to create new Shiny inputs.

## Input bindings {-}

- Upon initialization, Shiny runs several **JavaScript functions**.
- Some of those functions are **exposed through the Shiny JS object**.

Let's see an example:

1. Run the below app.

```{r}
#| eval: false

OSUICode::run_example(
 "input-system/dummy-app",
  package = "OSUICode"
)
```

2. Open the HTML inspector and the console you run `Shiny.unbindAll(document);`

3. The plot will stop changing regardless how much you the slicer.

4. Run `Shiny.bindAll(document);` to take the app back to normality.


## Adding JS to UI {-}

As `onclick` is a valid HTML attribute for the &lt;button&gt; tag, we can use it within Shiny's actionButton to __execute arbitrary JavaScript code__ when the button is clicked.


> `onclick` is supported for __all HTML elements__, EXCEPT: &lt;base&gt;, &lt;bdo&gt;, &lt;br&gt;, &lt;head&gt;, &lt;html&gt;, &lt;iframe&gt;, &lt;meta&gt;, &lt;param&gt;, &lt;script&gt;, &lt;style&gt;, and &lt;title&gt;



```{r}
#| eval: false

library(shiny)

ui <- fluidPage(
  actionButton(
    "unbind",
    "Unbind inputs",
    onclick = "Shiny.unbindAll();"
  ),
  actionButton(
    "bind",
    "Bind inputs",
    onclick = "Shiny.bindAll(document);"
  ),
  lapply(1:3, function(i) {
    textInput(paste0("text_", i), paste("Text", i))
  }),
  lapply(1:3, function(i) {
    uiOutput(paste0("val_", i))
  })
)

server <- function(input, output, session) {
  lapply(1:3, function(i) {
    output[[paste0("val_", i)]] <- renderPrint({
      input[[paste0("text_", i)]]
    })
  })
}

shinyApp(ui, server)
```

## Input structure {-}

- **id** guarantees the input uniqueness

- **type** defines how the element is displayed in several ways.

| Type | Type | Type | Type | Type |
|------|------|------|------|------|
| button | checkbox | color | date | datetime-local |
| email | file | hidden | image | month |
| number | password | radio | range | reset |
| search | submit | tel | text | time |
| url | week | | | |

- **class** may be required to find the element in the DOM. 

- **value** holds the input value.

```html
<input id = "id" type = "text" class = "..." value = value>
```

## Binding Shiny inputs {-}

The `InputBinding` methods are the set of instructions **you need to provide to Shiny** so it understands **how to interact with your custom HTML** input component by defining:

1.  **How to find** your input elements in the HTML.
2.  **How to get a unique ID** for each input instance.
3.  **What type of data** it represents.
4.  **How to extract the value** from your custom input.
5.  **How to detect when the value changes** and notify Shiny.
6.  **How to update your input** from the server.
7.  **How to manage communication frequency** for efficiency.
8.  **How to set up and clean up** your input element's resources.

> It relies on a class defined in the [`input_binding.js`](https://github.com/rstudio/shiny/blob/60db1e02b03d8e6fb146c9bb1bbfbce269231add/srcjs/input_binding.js)

## Binding Shiny inputs {-}

| Method Name           | Utility for Custom Inputs                                 | Description                                                                                                                                                                                                                                          |
|-----------------------|-----------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `find(scope)`         | **Element discovery**                                     | Defines how Shiny.js locates HTML elements within a given scope (e.g., a div) to treat as instances of your custom input. This method must be implemented for proper element selection.                                                         |
| `getId(el)`           | **Unique ID extraction**                                  | Retrieves a unique identifier for the input elementâ€”using `data-input-id` or the elementâ€™s `id`â€”to correctly link the client-side input with the corresponding Shiny server object.                                                           |
| `getType()`           | **Data type specification**                               | Returns the type of the input (e.g., "numeric", "character") so that the server can properly deserialize JSON data. If not specified, it defaults to a general type.                                                                           |

## Binding Shiny inputs {-}

| Method Name           | Utility for Custom Inputs                                 | Description                                                                                                                                                                                                                                          |
|-----------------------|-----------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `getValue(el)`        | **Value extraction**                                      | Core method for extracting the current value from the input element. It must be implemented to read the appropriate property or attribute reflecting the userâ€™s input.                                                                          |
| `subscribe(el, callback)` | **Reactivity and event handling**                     | Sets up event listeners (e.g., on 'change', 'keyup', or 'click') so that any input change triggers the provided callback. This keeps Shiny aware of real-time changes in your custom component.                                                |
| `unsubscribe(el)`     | **Resource cleanup**                                      | Removes event listeners attached in `subscribe`, ensuring efficient resource management and preventing memory leaks when the input is removed from the DOM.                                                                                         |


## Binding Shiny inputs {-}

| Method Name           | Utility for Custom Inputs                                 | Description                                                                                                                                                                                                                                          |
|-----------------------|-----------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `receiveMessage(el, data)` | **Server-controlled updates**                        | Allows the Shiny server to update the input element by sending new data (like value, min, or max) and triggers a change event. This method must be implemented to support dynamic updates from R.                                             |
| `getState(el)`        | **Comprehensive state capture**                           | Captures the complete state of the input (beyond just its value), which is useful for complex inputs with multiple properties. This state can then be communicated back to the server for restoration or analysis.                             |
| `getRatePolicy()`     | **Efficient server communication**                        | Specifies the rate at which input updates are sent to the server (using strategies like debounce or throttle). Defaults to `null` if not defined, but can be customized to optimize performance during rapid input changes.                     |


## Binding Shiny inputs {-}

| Method Name           | Utility for Custom Inputs                                 | Description                                                                                                                                                                                                                                          |
|-----------------------|-----------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `initialize(el)`      | **Initial setup**                                         | Invoked when the input element is first rendered or dynamically added, allowing for any required pre-binding initializationâ€”such as configuring JavaScript widgets or setting initial states.                                                     |
| `dispose(el)`         | **Teardown and cleanup**                                  | Called when an input element is removed, this method cleans up event listeners and any other resources to prevent memory leaks and maintain application efficiency.                                                                                |

## Re-create textInput {-}

1. Define where to store the binding JS methods to use.

```{r}
#| eval: false

customTextInputDeps <- function(binding_step) {
  htmlDependency(
    name = "customTextBindings",
    version = "1.0.0",
    src = c(file = system.file(
      "input-system/input-bindings", 
      package = "OSUICode"
    )),
    script = paste0(
      "customTextInputBinding_", 
      binding_step, 
      ".js"
    )
  )
}
```

## Re-create textInput {-}

2. Create an UI function with the new class `input-text` and JS dependency.

> The original `textInput()` use the binding based on input type.

```{r}
#| eval: false

customTextInput <- function (
  inputId, 
  label, 
  value = "", 
  width = NULL, 
  placeholder = NULL,
  binding_step
) {
  
  # this external wrapper ensure to control the input width
  div(
    class = "form-group shiny-input-container", 
    style = if (!is.null(width)) {
      paste0("width: ", validateCssUnit(width), ";")
    },
    # input label
    shinyInputLabel(inputId, label), 
    
    # input element + JS dependencies
    tagList(
      customTextInputDeps(binding_step),
      tags$input(
        id = inputId,
        type = "text",
        class = "form-control input-text",
        value = value,
        placeholder = placeholder
      )
    )
  )
}
```



## Re-create textInput {-}

3. Write the JS binding methods as you can see below for the [find](https://github.com/DivadNojnarg/OSUICode/blob/master/inst/input-system/input-bindings/customTextInputBinding_1.js) method.

```javascript
$(function() {
  // Input binding
  let customTextBinding = new Shiny.InputBinding();

  $.extend(customTextBinding, {
    find: function(scope) {
      console.log($(scope).find('.input-text'));
      return $(scope).find('.input-text');
    }
  });

  Shiny.inputBindings.register(customTextBinding, 'text');
});
```


## Re-create textInput {-}

Now we can wrap the input in simple app to see if the method is working in the inspector console.

```{r}
#| eval: false

library(shiny)
library(OSUICode)

customTextInputExample <- function(binding_step) {
  ui <- fluidPage(
    customTextInput(
      inputId = "caption",
      label = "Caption",
      value = "Data Summary",
      binding_step = binding_step
    ),
    textOutput("custom_text")
  )
  server <- function(input, output) {
    output$custom_text <- renderText(input$caption)
  }
  shinyApp(ui, server)
}
```


## Debbuging JS methods {-}

1. Run the app.

```{r}
#| eval: false

OSUICode::customTextInputExample(1)
```

2. Open the developer tools
3. On the sources tab, look for the `customTextInputBinding.js` script 
4. Put a breakpoints in the `find` method 
5. Reload the page
6. Type the console `$(scope).find('.input-text')` to display the DOM element

> If hover over the JavaScript output, the element will be highlighted.

![](image/12-understand-shiny-inputs/02-binding-find.png)

## Initialize inputs {-}

Upon initialization:

1. Shiny calls the `initializeInputs` function.
2. It takes **all input bindings** and **calls their initialize method** _**before binding all inputs**_.

The `initialize` method is **not always defined**

An exception is the Framework7 (used but `{shinyMobile}`) requires **instantiating all elements**.

```javascript
let f7ToggleBinding = new Shiny.InputBinding();
  $.extend(f7ToggleBinding, {
    initialize: function(el) {
      app.toggle.create({el: el});
    },
    // other methods
});
```

Where:

- `el: '.toggle'` means that we are looking at the element(s) having the `toggle` class.
- `app.toggle.create` is internal to the Framework7 API.

## Get the value {-}

The **getValue** method returns the input value _(different for almost all inputs)_ 

Where it is the example for the `textInput()`:

```javascript
getValue: function(el) {
  console.log($(el));
  return $(el).val();
}
```

Where:

- **el** refers to the element holding the id attribute and recognized by the find method.
- **val()** is extracting the `value` attribute


## Get the value {-}

If we applying this binding the can see that the app is now showing the output, but if try to update the input the **output won't update** a second time.

```{r}
#| eval: false

library(OSUICode)

customTextInputExample(2)
```

![](image/12-understand-shiny-inputs/03-get-value-binding.png)

## Updating Inputs From Server {-}

1. Define the **setValue** method.

```javascript
setValue: function(el, value) {
  $(el).val(value);
}
```

2. Define the **receiveMessage** method.

```javascript
receiveMessage: function(el, data) {
  console.log(data);
  if (data.hasOwnProperty('value')) {
    this.setValue(el, data.value);
  }
  // other parameters to update...
}
```

Where:

- `el` is the DOM element.
- `value` represents the new value.
- `data` are received from R as JS object

>  It is good practice to add a `data.hasOwnProperty` check to **avoid running code if the specified property does not exist**.

## Updating Inputs From R {-}

![](image/12-understand-shiny-inputs/04-shiny-update-inputs.png)

## Session Object (REMANDER) {-}

**session** is an instance of the [ShinySession](https://github.com/rstudio/shiny/blob/60db1e02b03d8e6fb146c9bb1bbfbce269231add/R/shiny.R#L338) **R6** class:

- It's **unique** to a given user
- It contains all information about input, output and client data

<br>

Exposes methods:

- **sendInputMessage** is used to update inputs from the server.
- **sendCustomMessage** sends messages from R to JS. _If `shiny.trace = TRUE` the sent JSON is displayed_.


## Sending one value from server {-}

1. Use the `getDefaultReactiveDomain()`function to **recover the current session**.
2. Use the **sendInputMessage** is used to update inputs from the server.

```{r}
#| eval: false

updateCustomTextInput <- function(
  inputId, 
  value = NULL, 
  session = getDefaultReactiveDomain()
) {
  session$sendInputMessage(inputId, message = value)
}
```

## Sending several values from server {-}

To pass multiple elements to update:

1. We can use `shiny:::dropNulls` internal function to ensure that the list does not contain NULL elements.
2. Pass the list to the **sendInputMessage**.

```{r}
#| eval: false

updateCustomTextInput <- function(
  inputId, 
  value = NULL, 
  placeholder = NULL, 
  session = getDefaultReactiveDomain()
) {
  message <- dropNulls(
    list(
      value = value,
      placeholder = placeholder
    )
  )
  session$sendInputMessage(inputId, message)
}
```


## Triggering the update from a buttom {-}

![](image/12-understand-shiny-inputs/05-update-input-text.png)

```{r}
#| eval: false

updateCustomTextInputExample <- function(binding_step) {
  ui <- fluidPage(
    customTextInput(
      "caption",
      "Caption",
      "Data Summary",
      binding_step = binding_step
    ),
    actionButton("update", "Update text!", class = "btn-success"),
    textOutput("custom_text")
  )

  server <- function(input, output, session) {
    output$custom_text <- renderText(input$caption)
    observeEvent(input$update, {
      updateCustomTextInput("caption", value = "new text")
    })
  }
  shinyApp(ui, server)
}
```



## Use the debbuger to send your own message {-}

1. Run the shiny app.

```{r}
#| eval: false

OSUICode::updateCustomTextInputExample(3)

```


2. Open the inspector and put breakpoints in the `receiveMessage` and `setValue` methods.

3. Reload the page.

4. Change the property `value` of object `data` with `data.value = "custom message";`

5. Click on the next arrow call `setValue`.

6. If you run `$(el).val(value);` in the debugger console, the DOM will be updated instantaneously with the new text.

> Please note that after clicking the button, the output **value still does not change**.


## Updating outputs when typing {-}

**subscribe** listens to events defining Shiny to update the input value and make it available in the app.

For that purpose we need to define the **event listeners** to update the app.

1. Use event `keyup` if you want to update *after a key is released on the keyboard*.
2. Use event `input` if you want to update *after copying and pasting any text in the input field or dictating text*.
3. The **callback** parameter ensures that the new value is *captured by Shiny*.


```javascript
subscribe: function(el, callback) {
      $(el).on('keyup.customTextBinding input.customTextBinding', function(event) {
        callback(true);
      }
```

```{r}
#| eval: false

OSUICode::updateCustomTextInputExample(4)

```

> Name convention used: EVENT_LISTENER.BINDING_NAME


## Updating outputs when clicking a buttom {-}

Solve this problem we need to:

1. Extend the definition of the `subscript` method by using the `change` event *(triggers when an element is updated)*.

```javascript
  subscribe: function(el, callback) {
    $(el).on('keyup.customTextBinding input.customTextBinding', function(event) {
      console.log(event);
      callback();
    });
  
    $(el).on('change.customTextBinding', function(event) {
      callback(false);
    });
  }
```

## Updating outputs when clicking a buttom {-}

2. Trigger a `change` event to trigger the subscribe method.

```javascript
  receiveMessage: function(el, data) {
    if (data.hasOwnProperty('value')) {
      this.setValue(el, data.value);
      $(el).trigger('change');
    }
  }
```

```{r}
#| eval: false

OSUICode::updateCustomTextInputExample(5)

```

## Setting rate policies {-}

If you want to change the input value **once the keyboard is completely released** for some time.

1. Define the **debounce** policy in the `getRatePolicy` method to *limit the rate at which a function can fire*, which allows a **delay** before telling Shiny to read the new value

```javascript
getRatePolicy: function() {
  return {
    policy: 'debounce', # direct or throttle
    delay: 250
  };
},
```

## Setting rate policies {-}

2. It's also important to pass `true` to the `callback` function.

```javascript
  subscribe: function(el, callback) {
    $(el).on('keyup.customTextBinding input.textInputBinding', function(event) {
      callback(true); 
    });

    $(el).on('change.customTextBinding', function(event) {
      callback();
    });
  },
```

```{r}
#| eval: false

OSUICode::updateCustomTextInputExample(6)

```

## Register an input binding {-}

```javascript
let myBinding = new Shiny.inputBinding();
  $.extend(myBinding, {
  // methods go here
});

Shiny.inputBindings.register(
  myBinding, 
  'PACKAGE_NAME.BINDING_NAME'
);
```

> Best practice is to name it following PACKAGE_NAME.BINDING_NAME, to avoid conflicts.

## Other binding methods {-}

There are also other methods that don't need to be changed most of the time:

- **getId** returns the object `id`.

- **getType** required to handle custom data formats.

## Edit an input binding {-}

1. Let's run the app without any new `Javascript`.

```r
library(shiny)
library(OSUICode)

ui <- fluidPage(
  actionButton("button1", icon("plus")),
  actionButton("button2", uiOutput("val")),
  actionButton("reset", icon("undo")),
  plotOutput("plot")
)

server <- function(input, output) {
  output$val <- renderUI({
    paste("Value: ", input$button2)
  })

  output$plot <- renderPlot({
    validate(
      need(
        input$button2 >= 10,
        message = "Only visible after 10 clicks on
        the second button"
      )
    )
    hist(rnorm(100))
  })

  observeEvent(input$reset, {
    if (input$button2 == 0) {
      showNotification(
        "Button successfuly reset",
        type = "warning"
      )
    }
  })
}

shinyApp(ui, server)
```


## Edit an input binding {-}

2. Check the needed changes.

```javascript
$(function() {

  // Wait for the `shiny:connected` event, so that the `Shiny` JS object exists
  $(document).on('shiny:connected', function(event) {
  
    // Unbind all inputs
    Shiny.unbindAll();
    
    // Extend the binding and edit its content
    // Access the binding registry
    $.extend(Shiny
      .inputBindings
      .bindingNames['shiny.actionButtonInput']
      .binding, {
        reset: function(el) {
         $(el).data('val', 0);
        },
        subscribe: function(el, callback) {
          $(el).on('click.actionButtonInputBinding', function(e) {
            var $el = $(this);
            var val = $el.data('val') || 0;
            $el.data('val', val + 1);

            callback();
          });

          $(el).on('change.actionButtonInputBinding', function(e) {
            debugger;
            callback();
          });

        }
      });
      
    // Apply the new changes with Shiny.bindAll()
    Shiny.bindAll();
  });

  $('#button1').on('click', function() {
    var $obj = $('#button2');
    var inputBinding = $obj.data('shiny-input-binding');
    var val = $obj.data('val') || 0;
    inputBinding.setValue($obj, val + 10);
    $obj.trigger('change');
  });

  $('#reset').on('click', function() {
    var $obj = $('#button2');
    var inputBinding = $obj.data('shiny-input-binding');
    inputBinding.reset($obj);
    $obj.trigger('change');
  });
});
```


## Edit an input binding {-}

3. Confirm its impact in the app.

```r
library(shiny)
library(OSUICode)

ui <- tagList(
  fluidPage(
    actionButton("button1", icon("plus")),
    actionButton("button2", uiOutput("val")),
    actionButton("reset", icon("undo")),
    plotOutput("plot")
  ),
  editBindingDeps()
)

server <- function(input, output) {
  output$val <- renderUI({
    paste("Value: ", input$button2)
  })

  output$plot <- renderPlot({
    validate(
      need(
        input$button2 >= 10,
        message = "Only visible after 10 clicks on
        the second button"
      )
    )
    hist(rnorm(100))
  })

  observeEvent(input$reset, {
    if (input$button2 == 0) {
      showNotification(
        "Button successfuly reset",
        type = "warning"
      )
    }
  })
}

shinyApp(ui, server)
```

## Capturing the state of a box in a (secundary) input {-}

1. Define an id for the element.
2. Add to JS dependencies the function `boxDeps()`.

```r
box <- function(.., id = NULL, title = NULL, footer = NULL,
                 background = NULL, width = 6, height = NULL,
                 collapsible = FALSE, collapsed = FALSE) {
  
  # ....; Extra code removed
  
  tagList(
    boxDeps(), # required to attach the binding
    div(
      class = if (!is.null(width)) paste0("col-sm-", width),
      div(
        id = id, # required to target the unique box
        class = boxClass, # required to target all boxes
        # ....; Extra code removed (box header, body, footer)
      )
    )
  )
}
```

## Capturing the state of a box in a (secundary) input {-}

1. Define an id for the element.
2. Add the JS dependencies to the function `boxDeps()`.

```r
boxDeps <- function() {
  htmlDependency(
    name = "boxBinding",
    version = "1.0.0",
    src = c(file = system.file("input-system/input-bindings", package = "OSUICode")),
    script = "boxBinding.js"
  )
}
```

## Capturing the state of a box in a (secondary) input {-}

3. Create an update function to change the status of the box.

```r
updateBox <- function(
  id, 
  session = getDefaultReactiveDomain()
) {
  session$sendInputMessage(id, message = NULL)
}
```

## Capturing the state of a box in a (secundary) input {-}

4. Defining the binding for the secundary input.

```javascript
let boxBinding = new Shiny.InputBinding();
$.extend(boxBinding, {
  find: function(scope) {
    return $(scope).find('.box');
  },
  getValue: function(el) {
    let isCollapsed = $(el).hasClass('collapsed-box');
    return {collapsed: isCollapsed}; // this will be a list in R
  },
  setValue: function(el, value) {
    $(el).toggleBox();
  },
  receiveMessage: function(el, data) {
    this.setValue(el, data);
    $(el).trigger('change');
  },
  subscribe: function(el, callback) {
    $(el).on('click', '[data-widget="collapse"]', function(event) {
      setTimeout(function() {
        callback();
      }, 50);
    });

    $(el).on('change', function(event) {
      setTimeout(function() {
        callback();
      }, 50);
    });
  },
  unsubscribe: function(el) {
    $(el).off('.boxBinding');
  }
});

Shiny.inputBindings.register(boxBinding, 'box-input');


$(function() {
  // overwrite box animation speed. Putting 500 ms add unnecessary delay for Shiny.
  $.AdminLTE.boxWidget.animationSpeed = 10;
});
```


## Capturing the state of a box in a (secundary) input {-}

Let's run the app before adding the JS code.

```r
library(shiny)
library(shinyWidgets)
library(OSUICode)

ui <- fluidPage(
  # import shinydashboard deps without the need of
  # the dashboard template
  useShinydashboard(),

  tags$style("body { background-color: ghostwhite};"),

  br(),
  box(
    title = textOutput("box_state"),
    "Box body",
    id = "mybox",
    collapsible = TRUE,
    plotOutput("plot")
  ),
  actionButton(
    "toggle_box",
    "Toggle Box",
    class = "bg-success"
  )
)

server <- function(input, output, session) {
  output$plot <- renderPlot({
    req(!input$mybox$collapsed)
    plot(rnorm(200))
  })

  output$box_state <- renderText({
    state <- if (input$mybox$collapsed) {
      "collapsed"
    } else {
      "uncollapsed"
    }
    paste("My box is", state)
  })

  observeEvent(input$toggle_box, {
    updateBox("mybox")
  })

}

shinyApp(ui, server)
```

## Getting rid of the `renderUI` {-}

Let's observe the effect of **slow rendering**.

> The whole piece of UI is re-rendered each time, while **only the box class** should be modified.

```r
library(shiny)
library(shinyWidgets)
library(OSUICode)

ui <- fluidPage(
  # import shinydashboard deps without the need of the
  # dashboard template
  useShinydashboard(),

  tags$style("body { background-color: ghostwhite};"),

  br(),
  uiOutput("custom_box"),
  
  br(),
  br(),
  selectInput(
    "widthvalue",
    "Width Value",
    choices = 6:12
  )
)

server <- function(input, output, session) {

  dummy_task <- reactive({
    Sys.sleep(5)
    input$widthvalue
  })

  output$custom_box <- renderUI({
    dummy_task()
    box(
      title = "Box",
      width = dummy_task(),
      "Box body",
      background = "blue"
    )
  })
}

shinyApp(ui, server)
```

## Getting rid of the `renderUI` {-}

1. Customize the previously designed `box()` function to **gather as many parameters as possible**.

    - `width` should be numeric
    - `title` might be any HTML tag or a list of HTML tags
    
2. Omit any `NULL` parameter from the `props` list.

```r
box2 <- function(..., id = NULL, title = NULL, footer = NULL,
                 background = NULL, width = 6, height = NULL,
                 collapsible = FALSE, collapsed = FALSE) {
  
  if (!is.null(title)) {
    processed_title <- if (
      inherits(title, "shiny.tag.list") ||
      inherits(title, "shiny.tag")
    ) {
      as.character(title)
    } else {
      title
    }
  }
  
  # We donâ€™t want to send empty arrays
  props <- dropNulls(
    list(
      title = processed_title,
      background = background,
      width = width
    )
  )
  
  # ....; Extra code removed
}
```

## Getting rid of the `renderUI` {-}

3. Convert our properties to a `JSON` with `toJSON()`.

4. Embed the `JSON` in a script tag with `data-for` attribute pointing to the unique `id` parameter.

```r
box2 <- function(..., id = NULL, title = NULL, footer = NULL,
                 background = NULL, width = 6, height = NULL,
                 collapsible = FALSE, collapsed = FALSE) {
  
  # ....; Extra code removed
  
  configTag <- tags$script(
    type = "application/json",
    `data-for` = id,
    jsonlite::toJSON(
      x = props,
      auto_unbox = TRUE,
      json_verbatim = TRUE
    )
  )
  
}
```

## Getting rid of the `renderUI` {-}

5. Add the configuration tag to the `box()` output.
6. Attach the *not-yet-designed* **`JS` dependencies with `tagList()`**.

```r
box2 <- function(..., id = NULL, title = NULL, footer = NULL,
                 background = NULL, width = 6, height = NULL,
                 collapsible = FALSE, collapsed = FALSE) {
  
  # ....; Extra code removed
  
  boxTag <- tagQuery(
    box(
      ..., id = id, title = title, footer = footer,
      background = background, width = width, height = height,
      collapsible = collapsible, collapsed = collapsed
    )
  )$
    append(configTag)$
    allTags()

  tagList(box2Deps(), boxTag)
}
```

## Getting rid of the `renderUI` {-}

5. Add the configuration tag to the `box()` output.
6. Attach the *not-yet-designed* **`JS` dependencies with `tagList()`**.

```r
box2Deps <- function() {
  htmlDependency(
    name = "boxBinding",
    version = "1.0.0",
    src = c(file = system.file(
      "input-system/input-bindings", 
      package = "OSUICode"
    )),
    script = "boxBindingEnhanced.js"
  )
}
```

## Getting rid of the `renderUI` {-}

7. Modify the `updateBox()` function to handle: 

    - Toggle
    - Update possibilities

```r
updateBox2 <- function(
  id, 
  action = c("toggle", "update"), 
  options = NULL,
  session = getDefaultReactiveDomain()
) {
  # for update, we take a list of options
  if (action == "update") {
    # handle case where options are shiny tag 
    # or a list of tags ...
    options <- lapply(options, function(o) {
      if (inherits(o, "shiny.tag") || 
          inherits(o, "shiny.tag.list")) {
        o <- as.character(o)
      }
      o
    })
    message <- dropNulls(
      c(
        action = action, 
        options = list(options)
      )
    )
    session$sendInputMessage(id, message)
  } else if (message == "toggle") {
    session$sendInputMessage(id, message = match.arg(action))
  }
}
```

## Getting rid of the `renderUI` {-}

7. Defining the new JS binding.

> Use the `_` prefix to make the difference between the **default input binding** methods and the **user-defined methods**.

```javascript
let boxBinding = new Shiny.InputBinding();

$.extend(boxBinding, {
  
  // we are using the same class
  find: function(scope) {
    return $(scope).find('.box');
  },
  
  // we still want to comunite to R
  // wheter the box is collapsed or not
  getValue: function(el) {
    let isCollapsed = $(el).hasClass('collapsed-box');
    return {collapsed: isCollapsed}; // this will be a list in R
  },
  
  // Just returns the config script:
  _getConfigScript: function(el) {
    return(
      // Starting from the box
      $(el)
        // We have to look one level up to be able to use the `find` method
        .parent()
        // Target the script tag for current id
        .find("script[data-for='" + el.id + "']")
    );
  },
  
  // Converts the script content to a JS object
  _processConfig: function(el) {
    return(
      JSON.parse(
        this
        ._getConfigScript(el)
        .html()
      )
    );
  },
  
  // user defined binding: update box width
  _updateWidth: function(el, o, n) {
  
    // removes old class
    $(el).parent().toggleClass("col-sm-" + o);
    $(el).parent().addClass("col-sm-" + n);
    
    // trigger resize so that output resize
    $(el).trigger('resize');
  },
  
  // Input binding default method
  setValue: function(el, value) {
    let config = this._processConfig(el);

    // Only apply change for action update
    if (value.action === "update") {
    
      // check whether value.options.width exists
      if (value.options.hasOwnProperty("width")) {
              
        // config.width returns the initial width
        // value.options.width contains the new width value
        //   provided in the updateBox2 message output
        if (value.options.width !== config.width) {
          this._updateWidth(
            el,
            config.width,
            value.options.width
          )
           
          // Updating the confing after changing the UI
          config.width = value.options.width;
        }
      }
      
      // other items to update
      if (value.options.hasOwnProperty("title")) {
        if (value.options.title !== config.title) {
          let newTitle;
          newTitle = `<h3 class="box-title">${value.options.title}</h3>`
          newTitle = $.parseHTML(newTitle);

          $(el)
            .find(".box-title")
            .replaceWith($(newTitle));

          config.title = value.options.title;
        }
      }

      // Donâ€™t forget to update the config script attached
      // to the card tag at the end of the update condition
      // OTHERWISE THE INPUT VALUE WONâ€™T BE MODIFIED
      this
        ._getConfigScript(el)
        .replaceWith(
          '<script type="application/json" data-for="' +
          el.id +
          '">' +
          JSON.stringify(config) +
          '</script>'
        );

    } else if (value.action === "toggle") {
      // if action is toggle
      $(el).toggleBox();
    }

  },
  receiveMessage: function(el, data) {
    this.setValue(el, data);
    $(el).trigger('change');
  },
  subscribe: function(el, callback) {
    $(el).on('click', '[data-widget="collapse"]', function(event) {
      setTimeout(function() {
        callback();
      }, 50);
    });

    $(el).on('change', function(event) {
      setTimeout(function() {
        callback();
      }, 50);
    });
  },
  unsubscribe: function(el) {
    $(el).off('.boxBinding');
  }
});

Shiny.inputBindings.register(boxBinding, 'box-input');


$(function() {
  // overwrite box animation speed. Putting 500 ms add unnecessary delay for Shiny.
  $.AdminLTE.boxWidget.animationSpeed = 10;
});
```

## Getting rid of the `renderUI` {-}

8. Combine all together in a new app.


```r
library(shiny)
library(shinyWidgets)
library(OSUICode)

ui <- fluidPage(
  # import shinydashboard deps without the need of the
  # dashboard template
  useShinydashboard(),

  tags$style("body { background-color: ghostwhite};"),

  br(),
  box2(id = "mybox",
       title = "Box",
       width = 6,
       "Box body",
       background = "blue"),
  
  br(),
  br(),
  selectInput(
    "widthvalue",
    "Width Value",
    choices = 6:12
  )
)

server <- function(input, output, session) {

  dummy_task <- reactive({
    Sys.sleep(5)
    input$widthvalue
  })

  observeEvent(dummy_task(), {
    updateBox2(
      "mybox",
      action = "update",
      options = list(
        width = dummy_task()
      )
    )
  })
}

shinyApp(ui, server)
```

## Using `Shiny.setInputValue` {-}

- Avoids the creation of an input binding **(faster to code)**.
- Can not be updated from R

> **Note:** If you need to set the input even when **the value did not change** you need to specify a priority option.

```javascript
Shiny.setInputValue('myinput', value, {priority: 'event'});
```

## `Shiny.setInputValue` and Shiny JavaScript events {-}

- On the R side, weâ€™ll access it with `input$isMac`.
- This allows you to conditionally display elements

```javascript
// 1. Wait for the shiny:connected event
$(document).on('shiny:connected', function(event) {
  
  // 2. Access to the Shiny JS object
  Shiny.setInputValue(
  
    // 3. Definine the id to use
    'isMac', 
    
    // 4. Confirm if the user has MacOS
    (navigator.appVersion.indexOf('Mac') != -1)
    
  );
  
});
```

## `Shiny.setInputValue` and Shiny JavaScript events {-}

```r
library(shiny)
library(OSUICode)
library(shinyWidgets)

ui <- fluidPage(
  useShinydashboard(),
  tags$head(
    tags$script(
      HTML("$(function() {
        $(document).on('shiny:connected', function(event) {
          Shiny.setInputValue(
            'isMac',
            (navigator.appVersion.indexOf('Mac') != -1)
          );
        });
      });"
    ))
  ),
  verbatimTextOutput("info"),
  box2(
    id = "mybox",
    title = "A box",
  )
)

server <- function(input, output) {
  output$info <- renderPrint(input$isMac)
  observeEvent({
    req(isTRUE(input$isMac))
  }, {
    updateBox2(
      "mybox",
      action = "update",
      options = list(
        title = "Only visible for Mac users"
      )
    )
  })
}

shinyApp(ui, server)
```

## Input handlers: without `getType` {-}

- Manipulate data generated on the JS side **before** injecting them in R.
- Can be added with the `registerInputHandler` function:

    - **type**: Allows the handler to connect to `Shiny.setInputValue` *(packageName.handlerName)*.
    - A **function** to transform data, having data as main parameter.

```r
library(shiny)

registerInputHandler("myPKG.textDate", function(data, ...) {
  if (is.null(data)) {
    NULL
  } else {
    res <- try(as.Date(unlist(data)), silent = TRUE)
    if ("try-error" %in% class(res)) {
      warning("Failed to parse dates!")
      data
    } else {
      res
    }
  }
}, force = TRUE)

ui <- fluidPage(
  tags$script(HTML(
    "$(function(){
      $(document).on('shiny:connected', function() {
        var currentTime = new Date();
        Shiny.setInputValue('time1', currentTime);
        Shiny.setInputValue(
          'time2:myPKG.textDate',
          currentTime
        );
      });
    });
    "
  )),
  verbatimTextOutput("res1"),
  verbatimTextOutput("res2")
)

server <- function(input, output, session) {
  output$res1 <- renderPrint({
    list(class(input$time1), input$time1)
  })
  output$res2 <- renderPrint({
    list(class(input$time2), input$time2)
  })
}

shinyApp(ui, server)
```

## Input handlers: with `getType` {-}

1. Add a custom data attribute to the input tag

```r
customTextInput <- function(...) {

type <- if (inherits(value, "Date")) {
  "date"
} else {
  NULL
}

tags$input(
  id = inputId,
  type = "text",
  class = "form-control input-text",
  value = value,
  placeholder = placeholder,
  `data-data-type` = type # NEW ATRIBUTE
)

}
```


## Input handlers: with `getType` {-}

2. Define our custom handler when the package is loaded.

```r
# on zzz.R

.onLoad <- function(...) {
  registerInputHandler(
    "OSUICode.textDate", function(data, ...) {
      if (is.null(data)) {
        NULL
      } else {
        res <- try(as.Date(unlist(data)), silent = TRUE)
        if ("try-error" %in% class(res)) {
          warning("Failed to parse dates!")
          data
        } else {
          res
        }
      }
  }, force = TRUE)
}

```

## Input handlers: with `getType` {-}

3. Edit the `getType` binding method

```r
getType: function getType(el) {
  var dataType = $(el).data("data-type");
  if (dataType === "date") return "OSUICode.textDate";
  else if (dataType === "number") return "OSUICode.textNumber";
  else return false; // Default behavior
},
```

> **Note:** To use the Shiny built-in handler, we could return "shiny.date" instead. 


## Extending input handlers with numbers {-}

1. Define an input handler for numeric data in the `zzz.R` file.

```r
registerInputHandler(
  "OSUICode.textNumber", function(data, ...) {
    if (is.null(data)) {
      NULL
    } else {
      res <- as.numeric(unlist(data))
      if (is.na(res)) {
        data
      } else {
        res
      }
    }
  }, force = TRUE)
```

## Extending input handlers with numbers {-}

2. Update the JavaScript `getType` method.

```javascript
getType: function getType(el) {
  var dataType = $(el).data('data-type');
  if (dataType === 'date') return 'OSUICode.textDate';
  else if (dataType === 'number') return 'OSUICode.textNumber';
  else return false;
}
```


## Extending input handlers with numbers {-}

3. Update the `customTextInput` function to manage numeric data.

```r
customTextInput <- function(...) {

type <- if (inherits(value, "Date")) {
  "date"
} else if (inherits(value, "numeric")) {
  "number"
} else {
  NULL
}

tags$input(
  id = inputId,
  type = "text",
  class = "form-control input-text",
  value = value,
  placeholder = placeholder,
  `data-data-type` = type # NEW ATRIBUTE
)

}
```


## Extending input handlers with numbers {-}

Let's see the app.

```
library(OSUICode)

customTextInputHandlerExample(7, "Nombre")
customTextInputHandlerExample(7, Sys.Date())
customTextInputHandlerExample(7, 5)
```

> **Note:** Since the `data-type` is set at app startup by checking the class of the value, **it will never change later**.

## Meeting Videos

### Cohort 1

`r knitr::include_url("https://www.youtube.com/embed/oab7Cm0iFbk")`

<details>
<summary> Meeting chat log </summary>

```
00:05:22	Russ:	Hi everyone
00:08:30	Russ:	start
00:08:40	Trevin Flickinger:	Hi ðŸ‘‹
00:26:37	Russ:	<3 physiology
01:07:38	Russ:	end
```
</details>
