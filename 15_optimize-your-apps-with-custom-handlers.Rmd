# Optimize your apps with custom handlers

```{r}
#| echo: false
#| output: false

library(htmltools)

create_note <- function(title = "Note",
                        text = ""){
  
  tags$div(class = "callout callout-style-default callout-note callout-titled",
           tags$div(class = "callout-header align-content-center",
                    tags$div(class = "callout-icon-container",
                             tags$i(class = "callout-icon")),
                    tags$div(class = "callout-title-container",
                             tags$p(id = "box-text", title))),
           tags$div(class = "callout-body-container callout-body",
                    tags$p(HTML(text))))
  
}
```


**Learning objectives:**

- Leverage internal Shiny JS tools to build **highly interactive** and **optimized** interfaces

## Introduction {-}

Many functions can update the UI from the server

- **update** functions
  - `updateTextInput()`, `updateTabSetPanel()`
- **toggle** functions
  - `hideTab()`, `showTab()`
- **modify** user interface elements
  - `renderUI()`, `insertUI()`, `removeUI()`
  
<br>

```{r}
#| echo: false

create_note(text = "The aren't many of this functions, which often obliges to use packages like <code>shinyjs</code> or write <strong>custom JavaScript code</strong>.")
```

## renderUI and uiOutput {-}

- `renderUI()` and `uiOutput` most famous way to **render** any HTML block from the **server**

- `update____` and `toggle` tools are component-specific, only target the element to modify

- `renderUI()` re-renders **the whole block** each time an associated _reactive dependency_ is invalidated.

- Results in **poor performances** in complex apps.

## renderUI and uiOutput Example {-}


```{r}
#| echo: false

create_note(text = "We used <code>do.call</code> to execute <code>dropdownMenu</code> in order to update the number of messages in the menu bar.")
```

```r
library(shiny)
library(bs4Dash)

new_message <- data.frame(
  message = "New message",
  from = "Paul",
  time = "yesterday",
  color = "success"
)

shinyApp(
  ui = dashboardPage(
    dark = FALSE,
    header = dashboardHeader(
      rightUi = uiOutput("messages", container = tags$li)
    ),
    sidebar = dashboardSidebar(),
    controlbar = dashboardControlbar(),
    footer = dashboardFooter(),
    title = "test",
    body = dashboardBody(actionButton("add", "Add message"))
  ),
  server = function(input, output) {
    
    messages <- reactiveValues(
      items = data.frame(
        message = rep("A message", 10),
        from = LETTERS[1:10],
        time = rep("yesterday", 10),
        color = rep("success", 10)
      )
    )
    
    observeEvent(input$add, {
      messages$items <- rbind(messages$items, new_message)
    })
    
    output$messages <- renderUI({
      lapply(seq_len(nrow(messages$items)), function(i) {
        items_i <- messages$items[i, ]
        bs4Dash::messageItem(
          message = items_i$message,
          from = items_i$from,
          time = items_i$time,
          color = items_i$color
        )
      }) |>
        c(badgeStatus = "danger",
          type = "messages") |>
        do.call(what = "dropdownMenu")
    })
  }
)

```



## renderUI and uiOutput Example {-}

```{r}
items = data.frame(
  message = rep("A message", 2),
  from = LETTERS[1:2],
  time = rep("yesterday", 2),
  color = rep("success", 2)
)

lapply(seq_len(nrow(items)), function(i) {
  items_i <- items[i, ]
  bs4Dash::messageItem(
    message = items_i$message,
    from = items_i$from,
    time = items_i$time,
    color = items_i$color
  )
}) |>
  c(badgeStatus = "danger",
    type = "messages") |>
  do.call(what = getExportedValue("bs4Dash", "dropdownMenu")) |>
  as.character() |>
  cat()
```


## Other Shiny handlers

### insertUI case

- `insertUI` sends a R message through `session$sendInsertUI`, via the **websocket**

- content is processed by `shiny:::processDeps()`

- Finds and resolves any HTML dependency

- For each dependency, makes sure the corresponding files can be accessed on the server with `createWebDependency()` and `addResourcePath()`

- Returns a list of the HTML element and dependencies. The HTML will be accessed by `message.content.html` and dependencies by `message.content.deps`

### Example

- If the item is inserted, the item counter as well as the dropdown text are not

- We may fix that by adding extra `insertUI()` and `removeUI()` to replace those parts

- order matters: ensure that **remove** happens before **insert**

- issue: a lot of server code!

- issue: setting priorities in `observeEvent()` is a rather bad smell of poorly designed Shiny app

## Custom handlers

### Theory

**session$sendCustomMessage(type, message)**. It works by pairing with the JS method **Shiny.AddCustomMessageHandler**, tightly linked by the type parameter

- example

### Toward custom UI managment functions

- we go back to the `bs4Dash::dropdownMenu()` issue

- create `insertMessageItem` with two parameters
 - **item**, the HTML element we want to insert in the DOM
 - **session**, used to send a message to JavaScript with `session$sendCustomMessage`
- We give it a **type**, that is `add-message-item`, to be able to identify it from JavaScript with `Shiny.addCustomMessageHandler`
- some JS stuff
- This solution significantly lightens the server code since everything may be done on the JS side in one step

### A chat system
- book example

## Meeting Videos

### Cohort 1

`r knitr::include_url("https://www.youtube.com/embed/l6BIOSHNCZA")`

<details>
<summary> Meeting chat log </summary>

```
00:03:14	Oluwafemi Oyedele:	Hello, Good Evening All!!!
00:03:24	James Arthur Shaw:	Reacted to "Hello, Good Evening ..." with ðŸ‘‹
00:03:24	Russ Hyde:	Hi everyone
00:08:34	Russ Hyde:	start
00:19:38	Federica Gazzelloni:	What invalidateLater(4000) would do instead?
01:01:58	Oluwafemi Oyedele:	Thank you!!!
01:04:57	Trevin Flickinger:	Note the session$ns that actually makes sure this function can work within shiny modules
01:06:38	Trevin Flickinger:	stop
01:06:42	Russ Hyde:	bye
```
</details>
